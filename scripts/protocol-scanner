#!/usr/bin/env -S bundle exec ruby
# -*- mode: ruby -*-
#
# Scans diode's ~protocol.md~ extracting 9p's request and reply
# message structures. These are turned into PackedStructs in the
# {NonoP::Protocol::Messages} module.
#

# fixme auth & attach

require 'erb'
require 'digest/sha2'
require 'sg/ext'
using SG::Ext

FULL_ARGV = ARGV.dup

class Request
  attr_accessor :name, :fields, :raw_fields
  
  def initialize name, fields, raw_fields = nil
    @name = name
    @fields = fields || []
    @raw_fields = raw_fields
  end

  def to_hash
    { name:, fields:, raw_fields: }
  end

  SizesToTypes = Hash.new { |h, k| k }.
    merge!({ '1' => :uint8,
             '2' => :uint16,
             '4' => :uint32,
             '8' => :uint64,
             's' => 'NonoP::NString',
             '*' => Array,
             '13' => 'NonoP::Qid'
           })
  
  def self.from_string str
    raw_fields = str.split
    size, name, *fields = raw_fields
    #scan(/(?:(\w+)(?:\[([^\]]*)\])?)|(?:(\w+)\*\(\w+\)\[(\w+)\])/).
    fields = fields.collect do |f|
      case f
      when /\A(\w+)\*\((\w+)\[(\w+)\]\)/ then [ $2.to_sym, SizesToTypes[$3], $1.to_sym ]
      when /\A(\w+)(?:\[([^0-9s*]+)\])/ then [ $1.to_sym, :uint8, $2.to_sym ]
      when /\A(\w+)(?:\[([^\]]*)\])?/ then [ $1.to_sym, SizesToTypes[$2 || '1'] ]
      else $stderr.puts("WARNING Unknown field format: #{f}")
      end
    end
    fields.delete_if { _1[0] == :tag }
    self.new(name, fields, raw_fields)
  end
end

class Definition
  attr_accessor :request, :reply, :name, :doc, :enums
  
  def initialize name, doc
    @name = name
    @doc = doc
    @doc = [ doc ]
    @enums = Hash.new { _1[_2] = Hash.new }
  end

  def to_hash
    { request:, reply:, doc:, name:, enums: }
  end
end

input_hash = Digest::SHA256.new
preamble = []
defs = []
definition = nil

ARGF.each_line do |line|
  input_hash << line

  if !definition && line !~ /\A\#+ \w+ -+/
    preamble << line.rstrip
    next
  end
  
  case line
  when /\A#+ (Sample Session|References)/ then break
  when
    /\A\#define P9_(\w+)_([^_]+_SET)\s+(\S*)(.*)/,
    /\A\#define P9_(GETATTR)_(\S+)\s+(\S*)(.*)/,
    /\A\#define P9_(\w+)_(\S+)\s+(\S*)(.*)/
  then
    definition.doc << line.rstrip
    definition.enums[$1][$2] = [ $3.gsub(/(0x[0-9a-fA-F]+)[UL]+/, '\1'), $4 ]
  when /\A#+ (\w+) -+ (.*)/ then defs << (definition = Definition.new($1, $2))
  when /\A#+ (\w+, \w+) -+ (.*)/ then defs << (definition = Definition.new($1, $2))
  when /\A```/ then true
  when /\Asize\[4\] (T\w+)/ then definition.request = Request.from_string(line)
  when /\Asize\[4\] (R\w+)/ then definition.reply = Request.from_string(line)
  else definition.doc << line.rstrip if definition
  end
end

# finish off the input
ARGF.each_line { input_hash << _1 }

def packing_for_fields fields
  fields.collect do |f|
    case f
      in [ name, type ] then "[ :%s, %s%s ]" % [ name, type.to_s =~ /\A[A-Z]/ ? '' : ':', type ]
      in [ name, type, size ] then "[ :%s, %s%s, %s%s ]" % [ name, type.to_s =~ /\A[A-Z]/ ? '' : ':', type, size =~ /\A\d+\Z/ ? '' : ':', size ]
    end
  end
end

def word_wrap_lines lines, width: 72
  lines.collect do |line|
    next line if line.size < width
    last, lines = line.split.reduce([ '', [] ]) do |(last, lines), word|
      if last.size + word.size < width
        [ last + ' ' + word, lines ]
      else
        [ word, lines << last ]
      end
    end
    lines << last
  end.flatten
end

def word_wrap str, width: 72
  word_wrap_lines(str.split("\n"), width:).join("\n")
end

req = ERB.new(<<-EOT, trim_mode: '-')
  \# Fields: <%= raw_fields.join(" ") %>
  class <%= name %>
    include NonoP::Packet::Data
    define_packing(<%= packing_for_fields(fields).join(",\n" + ' ' * 19) %>)
  end
EOT

enum = ERB.new(<<-EOT, trim_mode: '-')
  <%= name %> = {
<% values.each do |name, (value, comment)| -%>
    <%= name %>: <%= value %>,<% unless comment.blank? -%> # <%= comment %><% end %>
<% end -%>
  }
EOT

defsrc = ERB.new(<<-EOT, trim_mode: '-')
  \# <%= name %>
  \#
<%= word_wrap_lines(doc).collect { '  # ' + _1 }.join("\n") %>
<% if request -%>
<% if reply -%>  \# Replied with {<%= reply&.name || name %>}
<% end -%>
  \#
<%= req.result_with_hash(request.to_hash.merge(request: request)) -%>

<% end -%>
<% if reply -%>
<% if request -%>  \# Reply to {<%= request&.name || name %>}
<% end -%>
  \#
<%= req.result_with_hash(reply.to_hash.merge(request: request)) -%>

<% end -%>
<% unless enums.empty? -%>
<% enums.collect do |n, v| -%>
<%= enum.result_with_hash(name: n, values: v) -%>
<% end -%>
<% end -%>
EOT

src = ERB.new(<<-EOT, trim_mode: '-')
module NonoP
  module Protocol
    \# DO NOT EDIT. Auto-generated.
    \#
    \# |    Command | `<%= cmd.join(' ') %>` |
    \# |       Time | <%= Time.now %> |
    \# | Input hash | <%= hash.class.name.split('::')[-1] %>:<%= hash %> |
    \#
<%= word_wrap_lines(preamble).collect { '    # ' + _1 }.join("\n") %>
    module Messages
<% defs.collect do |d| -%>
<%= defsrc.result_with_hash(d.to_hash) %>
<% end -%>
    end
  end
end
EOT

puts src.result_with_hash(hash: input_hash, preamble:, defs:, cmd: [ $0, *FULL_ARGV ])
