#!/usr/bin/env -S bundle exec ruby
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'socket'
require 'nonop'
require 'munge'
require 'optparse'

$verbose = false
host = 'localhost'
port = 564
coder = nil
uid = Process.uid
uname = ENV['USER']
auth_creds = nil
aname = '/'
buffer_size = 4096
block_size = 4096

opts = OptionParser.new do |o|
  desc = 'Read a file from a file server.'
  o.banner += "\n\n" + desc + "\n\n"
  o.on('-H', '--help-banner') do
    puts(desc)
    exit(0)
  end
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('--host HOST') do |v|
    host = v
  end
  o.on('-p', '--port INTEGER', Integer) do |v|
    port = v
  end
  o.on('-P', '--protocol NAWE') do |v|
    coder = v
  end
  o.on('-u', '--uname NAME') do |v|
    uname = v
  end
  o.on('--uid INTEGER', Integer) do |v|
    uid = v.to_i
    uid = nil if uid < 0
  end
  o.on('--auth-creds CREDS') do |v|
    auth_creds = v
  end
  o.on('-n', '--no-auth') do
    auth_creds = false
  end
  o.on('-e', '--aname NAME') do |v|
    aname = v
  end
  o.on('--buffer-size BYTES', Integer) do |v|
    buffer_size = v
  end
  o.on('--block-size BYTES', Integer) do |v|
    block_size = v
  end
end

paths = opts.parse(ARGV)
paths << '' if paths.empty?

sock = TCPSocket.new(host, port)
coder = NonoP.coder_for(coder)
client = NonoP::Client.new(coder: coder, io: sock)

Signal.trap('INT') do
  client.close
end
Signal.trap('QUIT') do
  client.close
end

def parse_path path
  # todo files with colons?
  case path
  when /(.+[^\\]):(\d+)@(\d+)$/ then [ $1, $2&.to_i, $3&.to_i ]
  when /(.+[^\\]):(\d+)$/ then [ $1, $2&.to_i, nil ]
  when /(.+[^\\])@(\d+)$/ then [ $1, nil, $2&.to_i ]
  else [ path, nil, nil ]
  end.tap { |(p, cnt, off)| [ p.gsub(/:$/, ''), cnt, off ] }
end

# A read loop
def read_fn file, offset, length, block_size, &blk
  # todo move into RemoteFile?
  length ||= NonoP::MAX_U64
  NonoP::Async.reduce(Range.new(offset, offset + length).step(block_size),
                      offset) do |count, offset, &cc|
    file.read(block_size, offset: offset) do |data|
      raise data if StandardError === data # todo where is it handled?
      blk.call(data)
      cc.call(data.blank?, offset + data.bytesize) do |offset|
        # Close the file
        file.close
        # Continue on
        blk.call(nil)
      end
    end
  end
end

client.start do |pkt|
  main_loop = lambda do |*a|
    client.attach(uname: uname, aname: aname, n_uname: uid) do |attachment|
      raise attachment if StandardError === attachment
      # A loop through the paths but only after tte callbacks complete
      NonoP::Async.reduce(paths, []) do |path, counts, &cc|
        path, max_count, offset = parse_path(path)
        NonoP.vputs { "Reading path #{path} #{max_count} #{offset}" }
        attachment.open(path, flags: [:RDONLY]) do |file|
          fin = lambda do |final_count|
            NonoP.vputs { paths.zip(final_count).to_a.inspect }
            client.close
            $had_errors = final_count.any? { RuntimeError === _1  }
          end
          if StandardError === file
            $stderr.puts(file.message)
            cc.call(false, counts + [ file ], &fin)
          else
            count = 0
            read_fn(file, offset || 0, max_count, block_size) do |data|
              if data
                $stdout.write(data)
                count += data.bytesize
              else
                # next file
                cc.call(false, counts + [ count ], &fin)
              end
            end
          end
        end
      end
    end
  end

  if uid && auth_creds != false
    auth_creds ||= Munge.encode(uid: uid)
    client.auth(uname: uname,
                aname: aname,
                n_uname: uid,
                credentials: auth_creds,
                &main_loop)
  else
    main_loop.call
  end
end

client.read_loop

exit(1) if $had_errors
