#!/usr/bin/env -S bundle exec ruby
# -*- mode: ruby -*-

require 'sg/ext'
using SG::Ext

require 'nonop'
require 'nonop/command'

class CatCommand < NonoP::Command::Client
  attr_reader :aname, :block_size
  
  def initialize
    super
    @desc = 'Read a file from a file server.'
    @aname = '/'
    @block_size = 4096
  end
  
  def opts
    super.tap do |o|
      o.on('-e', '--aname NAME') do |v|
        @aname = v
      end
      o.on('--block-size BYTES', Integer) do |v|
        @block_size = v
      end
    end
  end

  def run args
    super do
      arguments << '' if arguments.empty?
      start_request_loop(arguments)
    end
    exit(1) unless @errors&.empty?
  end

  def parse_path path
    # todo files with colons?
    case path
    when /(.+[^\\]):(\d+)@(\d+)$/ then [ $1, $2&.to_i, $3&.to_i ]
    when /(.+[^\\]):(\d+)$/ then [ $1, $2&.to_i, nil ]
    when /(.+[^\\])@(\d+)$/ then [ $1, nil, $2&.to_i ]
    else [ path, nil, nil ]
    end.tap do |(p, cnt, off)|
      [ NonoP::RemotePath.new(p.gsub(/:$/, '')), cnt, off ]
    end
  end

  # A read loop
  def read_fn file, offset, length, block_size, &blk
    # todo move into RemoteFile?
    length ||= NonoP::MAX_U64
    NonoP::Async.reduce(Range.new(offset, offset + length).step(block_size),
                        offset) do |count, offset, &cc|
      file.read(block_size, offset: offset) do |data|
        NonoP.vputs { "Received #{data.class} #{data.to_s.size}" }
        raise data if StandardError === data # todo where is it handled?
        blk.call(data)
        cc.call(data == nil || data.empty?, offset + data.bytesize) do |status, offset|
          # Close the file
          file.close
          # Continue on
          blk.call(nil)
        end
      end.wait
    end
  end

  def finish_up paths, status, final_count
    NonoP.vputs { [ "Received:",
                    *paths.zip(final_count). collect { "  #{_1}: #{_2}" } ] }
    client.close
    @errors = paths.zip(final_count).select { StandardError === _2 }
  end

  def start_request_loop paths
    client.attach(uname: uname, aname: aname, n_uname: uid) do |attachment|
      raise attachment if NonoP::ErrorPayload === attachment
      # A loop through the paths but only after tte callbacks complete
      NonoP::Async.reduce(paths, []) do |path, counts, &cc|
        path, max_count, offset = parse_path(path)
        NonoP.vputs { "Reading path #{path} #{max_count} #{offset}" }
        attachment.open(path, flags: [:RDONLY]) do |file|
          if StandardError === file
            $stderr.puts("Error on #{path}: #{file}")
            NonoP.vputs { file.backtrace }
            cc.call(false, counts + [ file ]) { finish_up(paths, _1, _2) }
          else
            count = 0
            read_fn(file, offset || 0, max_count, block_size) do |data|
              if data
                $stdout.write(data)
                count += data.bytesize
              else
                # next file
                cc.call(false, counts + [ count ]) { finish_up(paths, _1, _2) }
              end
            end
          end
        end.wait
      end
    end.wait
  end
end

if __FILE__ == $0
  CatCommand.new.run(ARGV)
end
