#!/usr/bin/env -S bundle exec ruby
# -*- mode: ruby -*-

require 'sg/ext'
using SG::Ext

require 'nonop'
require 'nonop/command'

class PutCommand < NonoP::Command::Client
  attr_reader :aname, :block_size, :write_offset, :write_limit, :gid
  
  def initialize
    super
    @desc = 'Write a file to a file server.'
    @aname = '/'
    @block_size = 4096
    @write_offset = 0
    @write_limit = nil
    @gid = Process.gid
  end
  
  def opts
    super.tap do |o|
      o.on('--gid INTEGER', Integer) do |v|
        @gid = v.to_i
        raise ArgumentError.new("GID must be positive") if gid < 0
      end
      o.on('-e', '--aname NAME') do |v|
        @aname = v
      end
      o.on('--block-size BYTES', Integer) do |v|
        @block_size = v
      end
      o.on('--offset INTEGER', Integer) do |v|
        @write_offset = v
      end
      o.on('--limit INTEGER', Integer) do |v|
        @write_limit = v
      end
    end
  end

  def run args
    super do
      raise ArgumentError.new('No target specified.') if arguments.empty?

      if block_size >= client.server_info[:msize]
        block_size = client.server_info[:msize] - NonoP::Decoder::MIN_MSGLEN
      end

      put(reader, arguments[0])
    end
  end

  def put reader, target
    NonoP.vputs { "Put to #{target}" }
    client.attach(uname: uname, aname: aname, n_uname: uid) do |attachment|
      raise attachment if RuntimeError === attachment

      attachment.open(target, gid: gid, flags: [:WRONLY, :TRUNC, :CREATE]) do |file|
        raise file if RuntimeError === file

        NonoP::Async.reduce(reader, 0, write_offset, false) do |data_block, count, offset, err, &cc|
          NonoP.vputs { "Writing #{file.class} #{data_block&.bytesize || 'nil'} #{offset} #{count}" }
          file.write(data_block, offset: offset) do |reply|
            if nil == reply
              cc.call(true, count, offset, false, &method(:finish))
            elsif RuntimeError === reply
              cc.call(reply, count, offset, true, &method(:finish))
            else
              if data_block.bytesize < block_size
                file.close
              end

              cc.call(data_block.bytesize < block_size,
                      count + reply,
                      offset + reply,
                      reply < data_block.size, &method(:finish))
            end
          end
        end
      end
    end
  end    


  private
  
  def reader io = $stdin
    Enumerator.new do |y|
      begin
        data = io.read(block_size)
        y << data
      end until data.empty?
      raise StopIteration
    rescue IOError
      raise StopIteration
    end
  end
  
  def finish status, count, offset, err
    client.close
    if RuntimeError === status
      $stderr.puts("Error #{status.message}", *status.backtrace)
      exit(-1) if err
    else
      NonoP.vputs("ALL DONE")
    end
  end
  
end

if __FILE__ == $0
  PutCommand.new.run(ARGV)
end
