#!/usr/bin/env -S bundle exec ruby
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'socket'
require 'ninep'

if $0 == __FILE__
  require 'optparse'

  $verbose = false
  host = 'localhost'
  port = 564
  uid = 0
  uname = ''
  aname = '/'
  buffer_size = 4096
  
  def vputs(*)
    return unless $verbose
    puts(*)
  end

  opts = OptionParser.new do |o|
    o.on('-v', '--verbose') do
      $verbose = true
    end
    o.on('-u', '--uname NAME') do |v|
      uname = v
    end
    o.on('--uid INTEGER', Integer) do |v|
      uid = v.to_i
      uid = nil if uid < 0
    end
    o.on('-e', '--aname NAME') do |v|
      aname = v
    end
    o.on('--buffer-size BYTES', Integer) do |v|
      buffer_size = v
    end
  end

  paths = opts.parse(ARGV)
  paths << '' if paths.empty?

  sock = TCPSocket.new(host, port)
  client = NineP::Client.new(coder: NineP::L2000::Decoder.new,
                             io: sock)

  Signal.trap('INT') do
    client.close
  end
  Signal.trap('QUIT') do
    client.close
  end

  # A read loop
  def print_fn file, offset, length, paths, &blk
    file.read(length, offset: offset) do |data|
      raise data if StandardError === data
      $stdout.write(data)
      if length == data.bytesize
        # Read more
        print_fn(file, offset + length, length, paths, &blk)
      else
        # Close the file
        file.close
        # Continue on
        blk.call(paths)
      end
    end
  end

  def read_fn attachment, path = nil, *paths, buffer_size:, &blk
    # All done?
    return blk.call if blk && path == nil
    return if path == nil
    
    # Start reading the files
    $stderr.puts("%s" % [ path ])
    attachment.open(path, flags: [:RDONLY]) do |file|
      if StandardError === file
        $stderr.puts("Error: #{file.message}")
        next read_fn(attachment, *paths, buffer_size: buffer_size, &blk)
      end
      
      # Start the file read loop
      print_fn(file, 0, buffer_size, paths) do |rest_paths|
        # Read the next path
        read_fn(attachment, *rest_paths, buffer_size: buffer_size, &blk)
      end
    end
  end
  
  client.start do |pkt|
    if uid
      client.auth(uname: uname, aname: aname, n_uname: uid)
    end

    NineP::Client::Attachment.new(client: client, uname: uname, aname: aname, n_uname: uid) do |attachment|
      raise attachment if StandardError === attachment
      # A loop through the paths but only after tte callbacks complete
      read_fn(attachment, *paths, buffer_size: buffer_size) do
        client.clunk(0) do |pkt|
          client.close
        end
      end
    end
  end

  client.read_loop
end
