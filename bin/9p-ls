#!/usr/bin/env -S bundle exec ruby
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'socket'
require 'ninep'

if $0 == __FILE__
require 'optparse'

$verbose = false
host = 'localhost'
port = 564
uid = 0
uname = ''
aname = '/'
short_list = true
  
def vputs(*)
  return unless $verbose
  puts(*)
end

opts = OptionParser.new do |o|
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-u', '--uname NAME') do |v|
    uname = v
  end
  o.on('--uid INTEGER') do |v|
    uid = v.to_i
  end
  o.on('-e', '--aname NAME') do |v|
    aname = v
  end
  o.on('-l', '--long') do
    short_list = false
  end
end

def getattr(client, path, fid: 3)
  client.send_one(NineP::Packet.new(tag: 2,
    data: NineP::Twalk.new(
      fid: 0,
      newfid: fid,
      wnames: path.empty?? [] : path.split('/').collect { NineP::NString.new(_1) })))
  pkt = client.read_one
  vputs(pkt.tap { _1.data }.inspect)

  client.send_one(NineP::Packet.new(tag: 3,
    data: NineP::L2000::Tgetattr.new(fid: fid)))
  pkt = client.read_one
  vputs(pkt.tap { _1.data }.inspect)

  client.send_one(NineP::Packet.new(tag: 3,
                                    data: NineP::Tclunk.new(fid: fid)))
  vputs(client.read_one.tap { _1.data }.inspect)

  return pkt.data
end

paths = opts.parse(ARGV)
paths << '' if paths.empty?

sock = TCPSocket.new(host, port)
client = NineP::Client.new(coder: NineP::L2000::Decoder.new,
                           io: sock)

Signal.trap('INT') do
  client.close
end
Signal.trap('QUIT') do
  client.close
end

client.send_one(NineP::Packet.new(tag: -1, data: NineP::Tversion.new(msize: 65535, version: NineP::NString.new('9P2000.L'))))
vputs(client.read_one.tap { _1.data }.inspect)
if uid
  client.send_one(NineP::Packet.new(tag: 0,
    data: NineP::L2000::Tauth.new(
      afid: 0,
      uname: NineP::NString.new(uname),
      aname: NineP::NString.new(aname),
      n_uname: uid)))
  reply = client.read_one
  vputs(reply.tap { _1.data }.inspect)
  #exit(-1) if NineP::Rerror === reply.data
end
afid = reply.data.afid unless NineP::ErrorPayload === reply.data
client.send_one(NineP::Packet.new(tag: 0,
  data: NineP::L2000::Tattach.new(
    fid: 0,
    afid: afid || -1,
    uname: NineP::NString.new(uname),
    aname: NineP::NString.new(aname),
    n_uname: uid || -1)))
reply = client.read_one
vputs(reply.tap { _1.data }.inspect)
qid = reply.data.aqid if NineP::Rattach === reply.data

client.send_one(NineP::Packet.new(tag: 1,
  data: NineP::Twalk.new(
    fid: 0,
    newfid: 1,
    wnames: [ NineP::NString.new('/') ])))
vputs(client.read_one.tap { _1.data }.inspect)
client.send_one(NineP::Packet.new(tag: 3,
  data: NineP::Tclunk.new(fid: 1)))
vputs(client.read_one.tap { _1.data }.inspect)

paths.each do |path|
  client.send_one(NineP::Packet.new(tag: 2,
    data: NineP::Twalk.new(
      fid: 0,
      newfid: 2,
      wnames: path.empty?? [] : path.split('/').collect { NineP::NString.new(_1) })))
  pkt = client.read_one
  vputs(pkt.tap { _1.data }.inspect)

  unless short_list
    client.send_one(NineP::Packet.new(tag: 3,
                                      data: NineP::L2000::Tgetattr.new(fid: 2)))
    pkt = client.read_one
    vputs(pkt.tap { _1.data }.inspect)
    puts("\e[1m%s\e[0m" % [ path.empty?? '/' : path ])
    puts("\e[37m%s\e[0m" % [ pkt.data.to_h.inspect ])
  end
  
  client.send_one(NineP::Packet.new(tag: 2,
    data: NineP::L2000::Topen.new(
      fid: 2,
      flags: NineP::L2000::Topen::Flags[:DIRECTORY])))
  pkt = client.read_one
  vputs(pkt.tap { _1.data }.inspect)

  unless NineP::ErrorPayload === reply.data
    offset = 0
    max_name = 0
    dir_result = nil
    begin
      client.send_one(NineP::Packet.new(tag: 2,
        data: NineP::L2000::Treaddir.new(
          fid: 2,
          offset: offset,
          count: 256)))
      dir_result = client.read_one
      vputs(dir_result.tap { _1.data }.inspect)
      next if NineP::ErrorPayload === dir_result.data

      ents = dir_result.data.entries
      unless ents.blank?
        new_max_name = 2 + ents.collect { _1.name.to_s.size }.max
        max_name = new_max_name if max_name < new_max_name
        ents.each do |ent|  
          ent_stats = unless short_list
                        getattr(client, path + '/' + ent.name.to_s)
                      end
          if ent_stats == nil || NineP::ErrorPayload === ent_stats
            puts("  \e[1m%-*s\e[0m" %
                 [ max_name, ent.name.to_s ])
          else
            puts("  \e[1m%-*s \e[0;37m%8i %6o %8s %8s %18s\e[0m" %
                 [ max_name, ent.name.to_s, ent_stats.size, ent_stats.mode, ent_stats.uid, ent_stats.gid, Time.at(ent_stats.mtime_sec).strftime("%x %X") ])
          end
        end
        
        offset += ents.size
      end
    end until NineP::ErrorPayload === dir_result.data || dir_result.data.count == 0

    client.send_one(NineP::Packet.new(tag: 3,
      data: NineP::Tclunk.new(fid: 2)))
    vputs(client.read_one.tap { _1.data }.inspect)
  end
end

client.send_one(NineP::Packet.new(tag: 3,
  data: NineP::Tclunk.new(fid: 0)))
vputs(client.read_one.tap { _1.data }.inspect)
client.close
end
