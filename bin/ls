#!/usr/bin/env -S bundle exec ruby
# -*- mode: ruby -*-

require 'sg/ext'
using SG::Ext

require 'nonop'
require 'nonop/command'

class LsCommand < NonoP::Command::Client
  attr_reader :aname, :short_list, :sort_field, :reverse_sort
  def initialize
    super
    @desc = 'List a directory from a file server.'
    @aname = '/'
    @short_list = true
    @sort_field = :name
    @reverse_sort = false
  end

  def opts
    super.tap do |o|
      o.on('-e', '--aname NAME') do |v|
        @aname = v
      end
      o.on('-l', '--long') do
        @short_list = false
      end
      o.on('-s', '--sort FIELD') do |v|
        v = v.to_sym
        fields = [ :name, *NonoP::L2000::Rgetattr.members ]
        if fields.include?(v)
          @sort_field = v
        else
          raise ArgumentError.new("#{v} is not a valid field. Try: #{fields.collect(&:to_s).join(', ')}")
        end
      end
      o.on('-R', '--reverse') do
        @reverse_sort = true
      end
    end
  end

  def run args
    @errors = nil
    super do
      client.attach(uname: uname, aname: aname, n_uname: uid) do |attachment|
        raise attachment if RuntimeError === attachment

        arguments << '' if arguments.empty?
        NonoP::Async.reduce(arguments) do |path, &cc|
          ls_dir(attachment, path) do
            cc.call(false) do
              close
            end
          end
        end
      end
    end
    exit(1) if @errors
  end

  def ls_dir attachment, path, max_name: 0, &blk
    attachment.opendir(path) do |dir|
      puts("%s:" % [ path.empty?? '/' : path.to_s ])
      if RuntimeError === dir
        $stderr.puts("%s - %s" % [ path, dir ])
        @errors = true
        next blk.call
      end

      ents = read_dirents(dir)
      new_max_name = [ max_name, ents.collect { _1[0].name.size }.max || 0 ].max
      new_max_name = 2 + new_max_name
      max_name = new_max_name if max_name < new_max_name

      ents = if sort_field == :name
               ents.sort_by { _1[0].name }
             elsif sort_field
               ents.sort_by do
                 if !(NonoP::L2000::Rerror === _1[1]) && NonoP::Packet::Data === _1[1]
                   _1[1].send(sort_field)
                 else
                   NonoP::ComparableNil.instance
                 end
               end
             else
               ents
             end
      ents = ents.reverse if reverse_sort
      ents.each do |ent, ent_stats|
        print_dirent(ent, ent_stats, max_name)
      end

      blk.call
    end
  end

  def read_dirents dir
    dir.entries(wait_for: true).collect do |ent|
      if (sort_field && sort_field != :name) || !short_list
        stats = if client.remote_version == NonoP::L2000::Decoder::VERSION
                  dir.getattr(ent.name.to_s)
                else
                  dir.stat(ent.name.to_s)
                end
        [ ent, stats ]
      else
        [ ent ]
      end
    end
  end

  def print_dirent ent, stats, max_name
    NonoP.vputs { "Dirent #{ent.name} #{stats.inspect}" }
    if RuntimeError === stats
      puts("  \e[1m%-*s\e[0m %s" %
           [ max_name, ent.name.to_s, stats ])
    elsif NonoP::ErrorPayload === stats
      puts("  \e[1m%-*s\e[0m Error: %s" %
           [ max_name, ent.name.to_s,
             SystemCallError.new(ent.name.to_s, stats.code) ])
    elsif stats && !short_list
      puts("  \e[1m%-*s \e[0;37m%8i %10s %8s %8s %18s\e[0m" %
           [ max_name, ent.name.to_s,
             stats.size,
             NonoP.perm_mode_string(stats.mode),
             stats.uid, stats.gid,
             stats.mtime_sec.strftime("%x %X") ])
    else
      puts("  \e[1m%-*s\e[0m" %
           [ max_name, ent.name.to_s ])
    end
  end    
end

if __FILE__ == $0
  LsCommand.new.run(ARGV)
end
