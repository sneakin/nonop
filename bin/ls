#!/usr/bin/env -S bundle exec ruby
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'socket'
require 'ninep'

if $0 == __FILE__
require 'optparse'

$verbose = false
host = 'localhost'
port = 564
uid = 0
uname = ''
aname = '/'
short_list = true
  
def vputs(*)
  return unless $verbose
  puts(*)
end

opts = OptionParser.new do |o|
  desc = 'List a directory from a file server.'
  o.banner += "\n\n" + desc + "\n"
  o.on('--help-banner') do
    puts(desc)
    exit(0)
  end
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-u', '--uname NAME') do |v|
    uname = v
  end
  o.on('--uid INTEGER') do |v|
    uid = v.to_i
  end
  o.on('-e', '--aname NAME') do |v|
    aname = v
  end
  o.on('-l', '--long') do
    short_list = false
  end
end

paths = opts.parse(ARGV)
paths << '' if paths.empty?

sock = TCPSocket.new(host, port)
client = NineP::Client.new(coder: NineP::L2000::Decoder.new,
                           io: sock)

Signal.trap('INT') do
  client.close
end
Signal.trap('QUIT') do
  client.close
end

def dir_loop attachment, path = nil, *paths, max_name: 0, short_list: true, &blk
  return blk.call if path == nil
  
  attachment.opendir(path) do |dir|
    if StandardError === dir
      $stderr.puts("%s - %s" % [ path, dir ])
      next blk.call
    end

    new_max_name = 2 + dir.entries.collect { _1.name.to_s.size }.max
    max_name = new_max_name if max_name < new_max_name
    dir.entries do |ent|
      ent_stats = unless short_list
                    attachment.getattr(path + '/' + ent.name.to_s)
                  end
      if ent_stats == nil
        puts("  \e[1m%-*s\e[0m" %
             [ max_name, ent.name.to_s ])
      elsif StandardError === ent_stats
        puts("  \e[1m%-*s\e[0m %s" %
             [ max_name, ent.name.to_s, ent_stats ])
      else
        puts("  \e[1m%-*s \e[0;37m%8i %6o %8s %8s %18s\e[0m" %
             [ max_name, ent.name.to_s, ent_stats.size, ent_stats.mode, ent_stats.uid, ent_stats.gid, Time.at(ent_stats.mtime_sec).strftime("%x %X") ])
      end
    end

    dir_loop(attachment, *paths, max_name:, short_list:, &blk)
  end
end

def dir_loop attachment, paths, max_name: 0, short_list: true, &blk
  NineP::Async.reduce(paths) do |path, &cc|
    attachment.opendir(path) do |dir|
      if StandardError === dir
        $stderr.puts("%s - %s" % [ path, dir ])
        next cc.call(false, &blk)
      end

      # todo triggers multiple readdir requests
      new_max_name = 2 + dir.entries.collect { _1.name.to_s.size }.max
      max_name = new_max_name if max_name < new_max_name
      dir.entries do |ent|
        ent_stats = unless short_list
                      attachment.getattr(path + '/' + ent.name.to_s)
                    end
        if ent_stats == nil
          puts("  \e[1m%-*s\e[0m" %
               [ max_name, ent.name.to_s ])
        elsif StandardError === ent_stats
          puts("  \e[1m%-*s\e[0m %s" %
               [ max_name, ent.name.to_s, ent_stats ])
        else
          puts("  \e[1m%-*s \e[0;37m%8i %6o %8s %8s %18s\e[0m" %
               [ max_name, ent.name.to_s, ent_stats.size, ent_stats.mode, ent_stats.uid, ent_stats.gid, Time.at(ent_stats.mtime_sec).strftime("%x %X") ])
        end
      end

      cc.call(false, &blk)
    end
  end
end

client.start do |pkt|
  if uid
    client.auth(uname: uname, aname: aname, n_uname: uid)
  end

  client.attach(uname: uname, aname: aname, n_uname: uid) do |attachment|
    raise attachment if StandardError === attachment

    dir_loop(attachment, paths, short_list: short_list) do
      client.close
    end
  end
end

client.read_loop

end
