#!/usr/bin/env -S bundle exec ruby
# -*- coding: utf-8 -*-
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'ninep/server'
require 'munge'
require 'optparse'

require 'sg/io/reactor'

$verbose = false
listen_on = nil
port = 562
auth_db_path = nil
auth_provider = 'munge'
default_umask = File.umask
reactor_timeout = 5 # secs

opts = OptionParser.new do |o|
  desc = 'Run a file server.'
  o.banner += "\n\n" + desc + "\n\n"
  o.on('--help-banner') do
    puts(desc)
    exit(0)
  end
  o.banner = "9p Server"
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-p', '--port INT') do |v|
    port = v.to_i
  end
  o.on('-l', '--listen HOST') do |v|
    listen_on = v
  end
  o.on('--auth-provider PATH') do |v|
    auth_provider = v
  end
  o.on('--auth-db PATH') do |v|
    auth_db_path = v
  end
  o.on('--umask MASK') do |v|
    default_umask = v.to_i
  end
  o.on('--timeout SECS') do |v|
    reactor_timeout = v.to_i
  end
end
args = opts.parse(ARGV)

if $verbose
  puts "Listening on #{listen_on}:#{port}"
  puts "Args: #{args.join(', ')}"
end

users = {}
if auth_db_path
  File.open(auth_db_path, 'r') do |f|
    f.each_line do |line|
      name, uid, cred = line.split(':')
      users[name] = [ uid.to_i, cred ]
    end
  end
else
  users[ENV['USER']] = [ Process.uid, ENV['USER'] ]
  users['root'] = [ 0, 'root' ]
end

def format_server_stats stats
  max_name = stats.keys.collect { _1.to_s.size }.max
  stats.collect { "%-*s  %s" % [ max_name, _1, _2 ] }.join("\n") + "\n"
end

reactor = SG::IO::Reactor.new
auth = case auth_provider
       when 'munge' then NineP::Server::MungeAuth.new(users)
       when 'yes' then NineP::Server::YesAuth.new(users)
       else raise ArgumentError.new("Unknown auth provider: #{auth_provider}")
       end
srvenv = NineP::Server::Environment.new(reactor: reactor, authsrv: auth)

fs = NineP::Server::HashFileSystem.
  new(umask: default_umask,
      entries: {
        'abcd' => "1234\n",
        "utf8.txt" => "ðŸ˜»\n".freeze
      })
srvenv.export('/', fs)

require 'tempfile'
scratch_file = Tempfile.new

ctlfs = NineP::Server::HashFileSystem.
  new(umask: default_umask,
      entries: {
        'welcome' => "Hello!\n",
        'scratch' => NineP::Server::HashFileSystem::FileEntry.new('scratch', path: scratch_file.path, writeable: true),
        'README.md' => Pathname.new(__FILE__).parent.parent.join('README.md'),
        'info' => {
          'now' => lambda { Time.now },
          'stats' => lambda { format_server_stats(srvenv.stats) },
        },
        'config' => {
          'README' => "Configure the server by writing to these files.\n".freeze,
          'verbose' => NineP::Server::HashFileSystem::WriteableEntry.new('verbose') { |entry, data = nil, offset = 0|
            if data
              $verbose = entry.data.strip.to_bool
            end
            entry.data = $verbose.to_s + "\n"
          },
          'done' => NineP::Server::HashFileSystem::WriteableEntry.new('done') { |entry, data = nil, offset = 0|
            if data && entry.data.strip.to_bool
              srvenv.done! { reactor.done! }
            end
            entry.data || reactor.done?.to_s + "\n"
          }
        },
      })
srvenv.export('ctl', ctlfs)

listen_sock = TCPServer.new(listen_on, port)
reactor << SG::IO::Reactor::Listener.new(listen_sock, reactor) do |client|
  puts("Accepted client #{client}")
  conn = NineP::Server::Connection.new(client, srvenv)
  [ conn.input, conn.output ]
end

%w{INT QUIT}.each do |sig|
  Signal.trap(sig) { reactor.done! }
end

reactor.serve! timeout: reactor_timeout

puts("Goodbye.")
