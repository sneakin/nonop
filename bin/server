#!/usr/bin/env -S bundle exec ruby
# -*- coding: utf-8 -*-
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'nonop/server'
require 'munge'
require 'optparse'

require 'sg/io/reactor'

$verbose = false
listen_on = nil
port = 562
auth_db_path = nil
auth_provider = 'munge'
default_umask = File.umask
reactor_timeout = 5 # secs
exports = {}

opts = OptionParser.new do |o|
  desc = 'Run a file server.'
  o.banner += "\n\n" + desc + "\n\n"
  o.on('--help-banner') do
    puts(desc)
    exit(0)
  end
  o.banner = "9p Server"
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-p', '--port INT') do |v|
    port = v.to_i
  end
  o.on('-l', '--listen HOST') do |v|
    listen_on = v
  end
  o.on('--auth-provider PATH') do |v|
    auth_provider = v
  end
  o.on('--auth-db PATH') do |v|
    auth_db_path = v
  end
  o.on('--umask MASK') do |v|
    default_umask = v.to_i
  end
  o.on('--timeout SECS') do |v|
    reactor_timeout = v.to_i
  end
  o.on('-e', '--export NAME:PATH') do |v|
    name, path = v.split(':')
    raise ArgumentError.new("Export must be NAWE:PATH.") if name.blank? || path.blank?
    exports[name] = Pathname.new(path)
  end
end
args = opts.parse(ARGV)

if $verbose
  puts "Listening on #{listen_on}:#{port}"
  puts "Args: #{args.join(', ')}"
end

users = {}
if auth_db_path
  File.open(auth_db_path, 'r') do |f|
    f.each_line do |line|
      name, uid, cred = line.split(':')
      users[name] = [ uid.to_i, cred ]
    end
  end
else
  users[ENV['USER']] = [ Process.uid, ENV['USER'] ]
  users['root'] = [ 0, 'root' ]
end

def format_server_stats stats
  max_name = stats.keys.collect { _1.to_s.size }.max
  stats.collect { "%-*s  %s" % [ max_name, _1, _2 ] }.join("\n") + "\n"
end

reactor = SG::IO::Reactor.new
auth = case auth_provider
       when 'munge' then NonoP::Server::MungeAuth.new(users)
       when 'yes' then NonoP::Server::YesAuth.new(users)
       else raise ArgumentError.new("Unknown auth provider: #{auth_provider}")
       end
srvenv = NonoP::Server::Environment.new(reactor: reactor, authsrv: auth)

fs = NonoP::Server::HashFileSystem.
  new(umask: default_umask,
      entries: {
        'abcd' => "1234\n",
        "utf8.txt" => "ðŸ˜»\n".freeze
      })
srvenv.export('/', fs)

require 'tempfile'
scratch_file = Tempfile.new

ctlfs = NonoP::Server::HashFileSystem.
  new(umask: default_umask,
      entries: {
        'welcome' => "Hello!\n",
        'scratch' => NonoP::Server::HashFileSystem::PathEntry.new('scratch', scratch_file.path, writeable: true),
        'fifo' => NonoP::Server::HashFileSystem::FifoEntry.new('fifo'),
        'tmp' => NonoP::Server::HashFileSystem::DirectoryEntry.new('tmp', writeable: true),
        'src' => NonoP::Server::HashFileSystem::PathEntry.new('src', Pathname.new(__FILE__).dirname.dirname),
        'README.md' => Pathname.new(__FILE__).parent.parent.join('README.md'),
        'info' => {
          'now' => lambda { Time.now },
          'stats' => lambda { format_server_stats(srvenv.stats) },
        },
        'config' => {
          'README' => "Configure the server by writing to these files.\n".freeze,
          'verbose' => NonoP::Server::HashFileSystem::WriteableEntry.new('verbose') { |entry, data = nil, offset = 0|
            if data
              $verbose = entry.data.strip.to_bool
            end
            entry.data = $verbose.to_s + "\n"
          },
          'done' => NonoP::Server::HashFileSystem::WriteableEntry.new('done') { |entry, data = nil, offset = 0|
            if data && entry.data.strip.to_bool
              srvenv.done! { reactor.done! }
            end
            entry.data || reactor.done?.to_s + "\n"
          }
        },
      })
srvenv.export('ctl', ctlfs)

exports.each do |name, path|
  root = NonoP::Server::HashFileSystem::PathEntry.new('/', path)
  srvenv.export(name,
                NonoP::Server::HashFileSystem.new(umask: default_umask,
                                                  root: root))
end

listen_sock = TCPServer.new(listen_on, port)
reactor << SG::IO::Reactor::Listener.new(listen_sock, reactor) do |sock|
  conn = NonoP::Server::Connection.new(sock, srvenv)
  puts("Accepted client #{conn}")
  [ conn.input, conn.output ]
end

%w{INT QUIT}.each do |sig|
  Signal.trap(sig) { reactor.done! }
end

reactor.serve! timeout: reactor_timeout

puts("Goodbye.")
