#!/usr/bin/env -S bundle exec ruby
# -*- coding: utf-8 -*-
# -*-ruby-*-

require 'sg/ext'
using SG::Ext

require 'ninep'
require 'munge'
require 'optparse'

require 'sg/io/reactor'

$verbose = false
listen_on = nil
port = 562
auth_db_path = nil
auth_provider = nil

opts = OptionParser.new do |o|
  desc = 'Run a file server.'
  o.banner += "\n\n" + desc + "\n\n"
  o.on('--help-banner') do
    puts(desc)
    exit(0)
  end
  o.banner = "9p Server"
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-p', '--port INT') do |v|
    port = v.to_i
  end
  o.on('-l', '--listen HOST') do |v|
    listen_on = v
  end
  o.on('--auth-provider PATH') do |v|
    auth_provider = v
  end
  o.on('--auth-db PATH') do |v|
    auth_db_path = v
  end
end
args = opts.parse(ARGV)

if $verbose
  puts "Listening on #{listen_on}:#{port}"
  puts "Args: #{args.join(', ')}"
end

module NineP
  module Server
    class FileSystem
      def initialize
        @fids = {}
      end
      
      def qid
        @qid ||= NineP::Qid.new(type: NineP::Qid::Types[:MOUNT], version: 0, path: '/')
      end

      def close fid
        f = @fids.delete(fid)
        f&.call
        self
      end
      
      def walk path
        NineP.vputs { "Walking to #{path}" }
        if path.size == 0
          [ qid, 0 ]
        else
          false
        end
      end

      # todo stub api
    end

    class HashFileSystem
      BLOCK_SIZE = 4096

      MODE_DIR = 040000
      MODE_FILE = 0100000
      MODE_WRITEABLE = 0644
      MODE_READABLE = 0444
      MODE_EXECUTABLE = 0755
      
      DEFAULT_DIR_ATTRS = {
        valid: 1,
        mode: MODE_DIR | MODE_EXECUTABLE,
        uid: Process.uid,
        gid: Process.gid,
        nlink: 1,
        rdev: 0,
        blksize: BLOCK_SIZE,
        atime_sec: Time.now,
        atime_nsec: 0,
        mtime_sec: Time.now,
        mtime_nsec: 0,
        ctime_sec: Time.now,
        ctime_nsec: 0,
        btime_sec: Time.now,
        btime_nsec: 0,
        gen: 0,
        data_version: 0
      }

      DEFAULT_FILE_ATTRS = DEFAULT_DIR_ATTRS.
        merge(mode: MODE_FILE | MODE_WRITEABLE)

      class Entry
        attr_reader :name
        attr_accessor :data
        
        def initialize name, data
          @name = name
          @data = data
        end
        
        def qid
          @qid ||= NineP::Qid.new(type: NineP::Qid::Types[:FILE], version: 0, path: @name[0, 8])
        end

        def type
          0
        end

        def size
          data.bytesize
        end

        def data
          case @data
          when Proc then @data.call.to_s
          when Pathname then @data.read
          else @data
          end
        end

        def read count, offset = 0
          attrs[:atime_sec] = Time.now
          data[offset, count]
        end

        def close
          self
        end
        
        def truncate size = 0
          raise Errno::ENOTSUP unless String === @data
          @data = @data[0, size]
          attrs[:ctime_sec] = Time.now
          self
        end

        def write data, offset = 0
          raise Errno::ENOTSUP unless String === @data
          @data[offset, data.size] = data
          attrs[:mtime_sec] = Time.now
          data.size # todo bytesize?
        end

        def attrs
          @attrs ||= DEFAULT_FILE_ATTRS.
            merge(qid: qid,
                  mode: MODE_FILE | (String === @data ? MODE_WRITEABLE : MODE_READABLE))
        end
        
        def getattr
          attrs.merge(size: size, blocks: size / BLOCK_SIZE)
        end

      end

      class FSID
        attr_accessor :path, :open_flags
        def initialize path, open_flags: nil
          @path = path
          @open_flags = open_flags
        end

        def reading?
          m = @open_flags & NineP::L2000::Topen::Mask[:MODE]
          m == NineP::L2000::Topen::Flags[:RDONLY] ||
            m == NineP::L2000::Topen::Flags[:RDWR]
        end

        def writing?
          m = @open_flags & NineP::L2000::Topen::Mask[:MODE]
          m == NineP::L2000::Topen::Flags[:WRONLY] ||
            m == NineP::L2000::Topen::Flags[:RDWR]
        end
      end
      
      def initialize entries = nil
        @entries = Hash[(entries || {}).collect { |name, data| [ name,  Entry.new(name, data) ] }]
        @next_id = 0
        @fsids = {}
      end
      
      def qid
        @qid ||= NineP::Qid.new(type: NineP::Qid::Types[:MOUNT], version: 0, path: '/')
      end

      def qid_for path
        @entries.fetch(path).qid
      end

      def open fsid, flags
        NineP.vputs { "Opening #{fsid} #{@fsids[fsid]}" }
        return if fsid == 0

        id_data = @fsids.fetch(fsid)
        entry = @entries[id_data.path]
        if entry
          id_data.open_flags = flags

          case flags & NineP::L2000::Topen::Mask[:MODE]
          when NineP::L2000::Topen::Flags[:RDONLY] then true
          else
            if 0 != (flags & (NineP::L2000::Topen::Flags[:CREATE] || NineP::L2000::Topen::Flags[:TRUNC]))
              entry.truncate
            end
          end
        else
          raise Errno::ENOENT unless fsid == 0 || @entries.has_key?(@fsids.fetch(fsid).path)
        end
      rescue KeyError
        raise Errno::EBADFD
      end
      
      def close fsid
        id_data = @fsids.delete(fsid)
        self
      end

      def next_id
        @next_id += 1
      end

      def fsid_path fsid
        fsid == 0 ? '/' : @fsids.fetch(fsid).path
      end
      
      def walk path, old_fsid = nil
        NineP.vputs { "Walking to #{path} #{old_fsid}" }
        if path.size == 0
          if old_fsid == 0
            [ [], 0 ]
          else
            i = next_id
            @fsids[i] = case old_fsid
                        when nil then FSID.new(path.last)
                        else @fsids.fetch(old_fsid).dup
                        end
            [ [], i ]
          end
        elsif path.size == 1
          i = next_id
          @fsids[i] = FSID.new(path.last)
          entry = @entries[path.last]
          if entry
            [ [ entry.qid ], i ]
          else
            false
          end
        else
          false
        end
      end

      def readdir fsid, count, offset = 0
        case fsid
        when 0 then
          @entries.values[offset, count] || []
        else raise Errno::EBADFD
        end
      end

      def read fsid, count, offset = 0
        id_data = @fsids.fetch(fsid)
        raise Errno::EACCES unless id_data.reading?
        @entries.fetch(id_data.path).read(count, offset)
      rescue KeyError
        raise Errno::EBADFD
      end

      def write fsid, data, offset = 0
        id_data = @fsids.fetch(fsid)
        raise Errno::EACCES unless id_data.writing?
        @entries.fetch(id_data.path).write(data, offset)
      rescue KeyError
        raise Errno::EBADFD
      end

      def getattr fsid
        if fsid == 0
          DEFAULT_DIR_ATTRS.
            merge(qid: qid,
                  size: @entries.size,
                  blocks: @entries.size / BLOCK_SIZE)
        else
          @entries.fetch(@fsids.fetch(fsid).path).getattr
        end
      rescue KeyError
        raise Errno::EBADFD
      end
    end

    class AuthService
      def auth user, creds
        false
      end
      def find_user user
        nil
      end
      def has_user? user
        false
      end
      def user_count
        0
      end
    end

    class AuthHash < AuthService
      def initialize db
        @db = db
      end
      def auth user, creds
        u = find_user(user)
        u && u[1] == creds.strip
      end
      def find_user user
        case user
        when String then @db[user]
        when Integer then @db.find { _2[0] == user }&.then { _2 }
        else raise TypeError.new('User not a string or ID.')
        end
      end
      def has_user? user
        find_user(user) != nil
      end
      def user_count
        @db.size
      end
    end

    class YesAuth < AuthHash
      def auth user, creds
        return false unless has_user?(user)
        true
      end
    end

    class MungeAuth < AuthHash
      def auth user, creds
        return false unless has_user?(user)
        status, meta, payload = Munge.verify do |io|
          io.puts(creds)
        end
        status == 0 && meta.fetch('STATUS', '') =~ /^Success/ &&
          (Integer === user && meta.fetch('UID', '') =~ /\(#{user}\)/ ||
           String === user && meta.fetch('UID', '') =~ /#{user}/)
      end
    end

    class Stream
      def close
        @closed = true
      end
      def closed?
        @closed
      end
      def authentic? username, uid
        false
      end
      def open flags
        raise Errno::ENOTSUP
      end
      def readdir count, offset = 0
        raise Errno::ENOTSUP
      end
      def read count, offset = 0
        raise Errno::ENOTSUP
      end
      def write data, offset = 0
        raise Errno::ENOTSUP
      end
      def walk path
        raise Errno::ENOTSUP
      end
      def getattr mask
        raise Errno::ENOTSUP
      end
    end
    
    class ErrantStream < Stream
      include Singleton
    end

    class AuthStream < Stream
      def initialize environment, user, data = nil
        @environment = environment
        @user = user
        @data = data || ''
      end

      def write data, offset = 0
        raise EOFError.new if closed?
        @data[offset, data.size] = data
        data.size
      end

      def authentic? uname, uid
        NineP.vputs { [ "Authenticating #{@user}", @data.inspect, @environment.find_user(@user).inspect ] }
        (@user == uname || @user == uid) && @environment.auth(@user, @data)
      end

      def dup
        self.class.new(environment, user, data)
      end
    end

    class FileStream < Stream
      attr_reader :fs, :fid, :qids, :fsid
      
      def initialize fs, fid, qids, fsid
        @fs = fs
        @fid = fid
        @qids = qids
        @fsid = fsid
      end

      def dup
        self.class.new(fs, fid, qids, fsid)
      end

      def qid
        @qid ||= @qids[-1] || NineP::Qid.new(type: NineP::Qid::Types[:FILE], version: 0, path: @fs.fsid_path(@fsid)[0, 8])
      end

      def close
        @fs.close(@fsid)
      end

      def open flags
        @fs.open(@fsid, flags)
      end
      
      def readdir count, offset = 0
        @fs.readdir(@fsid, count, offset)
      end

      def read count, offset = 0
        @fs.read(@fsid, count, offset)
      end

      def write data, offset = 0
        @fs.write(@fsid, data, offset)
      end

      def walk path
        @fs.walk(path, @fsid)
      end

      def getattr mask
        @fs.getattr(@fsid)
      end
    end
      
    class AttachStream < Stream
      attr_reader :fs
      
      def initialize fs, fid
        @fs = fs
        @fid = fid
      end

      def dup
        self.class.new(fs, fid)
      end

      def close
        self
      end

      def walk path
        @fs.walk(path, 0)
      end

      def getattr mask
        @fs.getattr(0)
      end
    end
      
    class Environment
      attr_reader :authsrv, :auth_qid
      attr_reader :exports, :connections
      
      def initialize authsrv: nil
        @authsrv = authsrv
        @exports = {}
        @auth_qid = NineP::Qid.new(type: NineP::Qid::Types[:AUTH], version: 0, path: '')
        @started_at = Time.now
        @connections = {}
      end

      def export name, fs
        @exports[name] = fs
        self
      end

      def get_export name
        @exports.fetch(name)
      end

      delegate :auth, :find_user, :has_user?, to: :authsrv

      def track_connection conn
        @connections[conn] = conn
        self
      end

      def untrack_connection conn
        @connections.delete(conn)
        self
      end
      
      def stats
        { exports: exports.size,
          connections: connections.size,
          users: authsrv.user_count,
          now: Time.now,
          uptime: Time.now - @started_at,
          started_at: @started_at
        }
      end
    end
    
    class Connection
      attr_reader :io, :coder, :input, :output, :environment
      
      def initialize io, env
        @io = io
        @environment = env
        @coder = NineP::L2000::Decoder.new
        @output = SG::IO::Reactor::QueuedOutput.new(@io)
        @input = SG::IO::Reactor::BasicInput.new(@io) { handle }
        @open_fids = Hash.new(ErrantStream.instance)
        env.track_connection(self)
      end

      def close
        return if closed?
        NineP.vputs { "Closing #{self}" }
        @output.close
        @io.close
        environment.untrack_connection(self)
        @closed = true
        self
      end

      def closed?
        @closed
      end

      def reply_to pkt, msg
        coder.send_one(NineP::Packet.new(tag: pkt.tag, data: msg),
                       output)
      rescue SystemCallError
        NineP.vputs { "Error sending reply: #{$!.message}" }
        close
      end
      
      def handle
        pkt = coder.read_one(@io)
        case pkt.data
        when NineP::Tversion then
          reply_to(pkt, NineP::Rversion.new(msize: coder.max_msglen,
                                            version: NineP::NString.new(coder.version)))
        when NineP::L2000::Tauth then
          if environment.has_user?(pkt.data.n_uname)
            @open_fids[pkt.data.afid] = AuthStream.new(environment, pkt.data.n_uname)
            reply_to(pkt, NineP::L2000::Rauth.new(aqid: environment.auth_qid))
          else
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EACCES))
          end            
        when NineP::L2000::Tattach then
          # todo creates a fid
          begin
            stream = @open_fids.fetch(pkt.data.afid)
            if stream.authentic?(pkt.data.uname, pkt.data.n_uname)
              @open_fids[pkt.data.fid] = ErrantStream.instance
              reply_to(pkt, NineP::L2000::Rattach.new(aqid: environment.auth_qid))
            else
              reply_to(pkt, NineP::L2000::Rerror.new(Errno::EACCES))
            end
          rescue KeyError
            if pkt.data.afid == 0xFFFFFFFF
              begin
                fs = environment.get_export(pkt.data.aname.to_s)

                if pkt.data.uname != nil || 0xFFFFFFFF == pkt.data.n_uname
                  # todo auth against per export databases
                  user = pkt.data.n_uname == 0xFFFFFFFF ? pkt.data.uname.to_s : pkt.data.n_uname
                  NineP.vputs { "Authenticating #{user}" }
                  if environment.auth(user, nil)
                    @open_fids[pkt.data.fid] = AttachStream.new(fs, pkt.data.fid)
                    reply_to(pkt, NineP::L2000::Rattach.new(aqid: environment.auth_qid))
                  else
                    reply_to(pkt, NineP::L2000::Rerror.new(Errno::EACCES))
                  end
                else
                  @open_fids[pkt.data.fid] = AttachStream.new(fs, pkt.data.fid)
                  reply_to(pkt, NineP::L2000::Rattach.new(aqid: fs.qid))
                end
              rescue KeyError
                reply_to(pkt, NineP::L2000::Rerror.new(Errno::ENOENT))
              end
            else
              reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
            end
          end
        when NineP::Twrite then
          begin
            stream = @open_fids.fetch(pkt.data.fid)
            reply_to(pkt, NineP::Rwrite.new(count: stream.write(pkt.data.data, pkt.data.offset)))
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        when NineP::Tread then
          begin
            stream = @open_fids.fetch(pkt.data.fid)
            reply_to(pkt, NineP::Rread.new(data: stream.read(pkt.data.count, pkt.data.offset)))
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        when NineP::Tclunk then
          if stream = @open_fids.delete(pkt.data.fid)
            stream.close
            reply_to(pkt, NineP::Rclunk.new)
          else
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          end
        when NineP::Twalk then
          begin
            # Empty list needs to make a new fid
            stream = @open_fids.fetch(pkt.data.fid)
            qids, fsid = stream.walk(pkt.data.wnames.collect(&:to_s))
            NineP.vputs { "Walked #{pkt.data.wnames} #{qids.inspect}" }
            if qids && fsid
              new_stream = FileStream.new(stream.fs, pkt.data.newfid, qids, fsid)
              @open_fids[pkt.data.newfid] = new_stream
              reply_to(pkt, NineP::Rwalk.new(wqid: qids))
            else
              reply_to(pkt, NineP::L2000::Rerror.new(Errno::ENOENT))
            end
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        when NineP::L2000::Topen then
          stream = @open_fids.fetch(pkt.data.fid)
          NineP.vputs { "Opening #{pkt.data.fid} #{stream.qid.inspect} #{stream.inspect}" }
          begin
            stream.open(pkt.data.flags)
            reply_to(pkt, NineP::Ropen.new(qid: stream.qid || stream.fs.qid,
                                           iounit: 0))
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        when NineP::L2000::Treaddir then
          begin
            stream = @open_fids.fetch(pkt.data.fid)
            NineP.vputs { "Reading dir #{pkt.data.fid} #{stream.inspect}" }
            ents = stream.readdir(pkt.data.count, pkt.data.offset).
              each.with_index.
              collect { NineP::L2000::Rreaddir::Dirent.new(qid: _1.qid,
                                                           offset: _2 + 1,
                                                           type: _1.type,
                                                           name: NineP::NString.new(_1.name)) }
            reply_to(pkt, NineP::L2000::Rreaddir.new(entries: ents))
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        when NineP::L2000::Tgetattr then
          begin
            stream = @open_fids.fetch(pkt.data.fid)
            NineP.vputs { "Getattr #{pkt.data.fid} #{stream.inspect}" }
            stats = stream.getattr(pkt.data.request_mask)
            NineP.vputs { "   #{stats.inspect}" }
            reply_to(pkt, NineP::L2000::Rgetattr.new(**stats))
          rescue KeyError
            reply_to(pkt, NineP::L2000::Rerror.new(Errno::EBADFD))
          rescue SystemCallError
            reply_to(pkt, NineP::L2000::Rerror.new($!))
          end
        else
          reply_to(pkt, NineP::L2000::Rerror.new(Errno::ENOTSUP))
        end
      rescue SG::PackedStruct::NoDataError, Errno::ECONNRESET
        if io.eof?
          puts("Closed #{io}")
        else
          $stderr.puts("Error on #{io}: #{$!.message}")
        end
        close
      rescue NineP::Error
        $stderr.puts("Error on #{io}: #{$!.message}")
        reply_to(pkt, NineP::L2000::Rerror.new($!))
        close
      end
    end
  end
end

users = {}
if auth_db_path
  File.open(auth_db_path, 'r') do |f|
    f.each_line do |line|
      name, uid, cred = line.split(':')
      users[name] = [ uid.to_i, cred ]
    end
  end
else
  users[ENV['USER']] = [ Process.uid, ENV['USER'] ]
  users['root'] = [ 0, 'root' ]
end

def format_server_stats stats
  max_name = stats.keys.collect { _1.to_s.size }.max
  stats.collect { "%-*s  %s" % [ max_name, _1, _2 ] }.join("\n") + "\n"
end

auth = case auth_provider
       when 'munge' then NineP::Server::MungeAuth.new(users)
       when 'yes' then NineP::Server::YesAuth.new(users)
       else raise ArgumentError.new("Unknown auth provider: #{auth_provider}")
       end
fs = NineP::Server::HashFileSystem.
  new('abcd' => "1234\n",
      "utf8.txt" => "ðŸ˜»\n")
srvenv = NineP::Server::Environment.new(authsrv: auth).
  export('/', fs)
ctlfs = NineP::Server::HashFileSystem.
  new('welcome' => "Hello!\n",
      'README.md' => Pathname.new(__FILE__).parent.parent.join('README.md'),
      'now' => lambda { Time.now },
      'stats' => lambda { format_server_stats(srvenv.stats) })
srvenv.export('ctl', ctlfs)

listen_sock = TCPServer.new(listen_on, port)

reactor = SG::IO::Reactor.new
reactor << SG::IO::Reactor::Listener.new(listen_sock, reactor) do |client|
  puts("Accepted client #{client}")
  conn = NineP::Server::Connection.new(client, srvenv)
  [ conn.input, conn.output ]
end

%w{INT QUIT}.each do |sig|
  Signal.trap(sig) { reactor.done! }
end

reactor.serve! timeout: 5
