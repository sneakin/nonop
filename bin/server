#!/usr/bin/env -S bundle exec ruby
# -*- mode: ruby -*-
# -*- coding: utf-8 -*-

require 'sg/ext'
using SG::Ext

require 'nonop/server'
require 'munge'
require 'optparse'

require 'sg/io/reactor'

$verbose = ENV['VERBOSE'].to_bool
listen_on = nil
port = 562
auth_db_path = nil
auth_provider = 'munge'
needs_prior_auth = true
acl_path = 'YES'
default_umask = File.umask
reactor_timeout = 5 # secs
exports = {}

opts = OptionParser.new do |o|
  desc = 'Run a file server.'
  o.banner += "\n\n" + desc + "\n\n"
  o.on('--help-banner') do
    puts(desc)
    exit(0)
  end
  o.banner = "9p Server"
  o.on('-v', '--verbose') do
    $verbose = true
  end
  o.on('-p', '--port INT') do |v|
    port = v.to_i
  end
  o.on('-l', '--listen HOST') do |v|
    listen_on = v
  end
  o.on('--[no-]prior-auth') do |v|
    needs_prior_auth = v
  end
  o.on('--auth-provider PATH') do |v|
    auth_provider = v
  end
  o.on('--auth-db PATH') do |v|
    auth_db_path = v
  end
  o.on('--acl PATH') do |v|
    acl_path = v
  end
  o.on('--umask MASK') do |v|
    default_umask = v.to_i
  end
  o.on('--timeout SECS') do |v|
    reactor_timeout = v.to_i
  end
  o.on('-e', '--export NAME:PATH:RW') do |v|
    name, path, mode = v.split(':')
    raise ArgumentError.new("Export must be NAME:PATH.") if name.blank? || path.blank?
    exports[name] = [ Pathname.new(path), mode&.downcase == 'rw' ]
  end
end
args = opts.parse(ARGV)

if $verbose
  puts "Listening on #{listen_on}:#{port}"
  puts "Args: #{args.join(', ')}"
end

users = {}
if auth_db_path
  File.open(auth_db_path, 'r') do |f|
    f.each_line do |line|
      name, uid, cred = line.split(':')
      users[name] = [ uid.to_i, cred ]
    end
  end
else
  users[ENV['USER']] = [ Process.uid, ENV['USER'] ]
  users['root'] = [ 0, 'root' ]
end

acl = case acl_path
      when /\.rb\Z/ then
        NonoP::Server::ACL.from_script(acl_path)
      when /\.json\Z/ then NonoP::Server::HashAcl.new(JSON.load(File.read(acl_path)))
      when 'YES' then NonoP::Server::YesAcl.new
      else raise ArgumentError.new("Unknown ACL: #{acl_path}")
      end

reactor = SG::IO::Reactor.new
auth = case auth_provider
       when 'munge' then NonoP::Server::MungeAuth.new
       when 'yes' then NonoP::Server::YesAuth.new(users)
       else raise ArgumentError.new("Unknown auth provider: #{auth_provider}")
       end
srvenv = NonoP::Server::Environment.
  new(reactor: reactor,
      authsrv: auth,
      acl: acl,
      needs_prior_auth: needs_prior_auth)

require 'tempfile'
scratch_file = Tempfile.new

def format_server_stats stats
  max_name = stats.keys.collect { _1.to_s.size }.max
  stats.collect { "%-*s  %s" % [ max_name, _1, _2 ] }.join("\n") + "\n"
end

ctlfs = NonoP::Server::HashFileSystem.
  new(umask: default_umask,
      entries: {
        'README.md' => Pathname.new(__FILE__).parent.parent.join('README.md'),
        'info' => {
          'now' => lambda { Time.now },
          'stats' => lambda { format_server_stats(srvenv.stats) },
        },
        'config' => {
          'README' => "Configure the server by writing to these files.\n".freeze,
          'verbose' => NonoP::Server::FileSystem::WriteableEntry.new('verbose') { |entry, data = nil, offset = 0|
            if data
              $verbose = entry.data.strip.to_bool
            end
            entry.data = $verbose.to_s + "\n"
          },
          'done' => NonoP::Server::FileSystem::WriteableEntry.new('done') { |entry, data = nil, offset = 0|
            if data && entry.data.strip.to_bool
              srvenv.done! { reactor.done! }
            end
            entry.data || reactor.done?.to_s + "\n"
          }
        },
      })
srvenv.export('ctl', ctlfs)

exports.each do |name, (path, writeable)|
  fs = if path.directory?
         root = NonoP::Server::FileSystem::PathEntry.new('/', path, writeable: writeable)
         NonoP::Server::HashFileSystem.new(umask: default_umask,
                                           root: root)
       elsif path.to_s =~ /\.(rb|nonofs)\Z/
         instance_eval(File.read(path), path.to_s)
       else
         raise ArgumentError.new("Only directories and scripts can be exported.")
       end
  srvenv.export(name, fs)
end

listen_sock = TCPServer.new(listen_on, port)
reactor << SG::IO::Reactor::Listener.new(listen_sock, reactor) do |sock|
  conn = NonoP::Server::Connection.new(sock, srvenv)
  puts("Accepted client #{conn}")
  [ conn.input, conn.output ]
end

%w{INT QUIT}.each do |sig|
  Signal.trap(sig) { reactor.done! }
end

reactor.serve! timeout: reactor_timeout

puts("Goodbye.")
